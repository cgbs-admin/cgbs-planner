import React, { useState, useEffect } from "react";
import Login from "./components/Login";
import {
  loadAuthTokenFromStorage,
  getAuthToken,
  setAuthToken,
  apiFetch,
} from "./api";
import AddEventForm from "./components/AddEventForm";
import { CategoryManagement } from "./components/Categories";
import { PlanningLevelsPanel } from "./components/PlanningLevels";
import AppLayout from "./components/AppLayout";

type Category = {
  id: number;
  name: string;
  symbol?: string | null;
  color_hex?: string | null;
};

type PlanningLevel = {
  id: number;
  name: string;
};

type Event = {
  id: number;
  title: string;
  start_date?: string | null;
  end_date?: string | null;
  start_time?: string | null;
  end_time?: string | null;
  preacher?: string | null;
  sermon_title?: string | null;
  remarks?: string | null;
  internal_notes?: string | null;
  clarification?: string | null;
  link?: string | null;
  parent_id?: number | null;
  categories?: Category[];
  planning_levels?: PlanningLevel[];
};

const cardBaseStyle: React.CSSProperties = {
  borderRadius: "12px",
  border: "1px solid #e5e7eb",
  padding: "1rem",
  backgroundColor: "#ffffff",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.06)",
};

const subtleTextStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#6b7280",
};



const formatDisplayDate = (event: Event): string => {
  const { start_date, end_date } = event;
  if (!start_date && !end_date) {
    return "";
  }

  const formatOne = (value: string | null | undefined): string => {
    if (!value) return "";
    const dt = new Date(value);
    if (Number.isNaN(dt.getTime())) return value;
    return dt.toLocaleDateString(undefined, {
      weekday: "short",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    });
  };

  const startLabel = formatOne(event.start_date ?? undefined);
  const endLabel = formatOne(event.end_date ?? undefined);

  if (startLabel && endLabel && endLabel != startLabel) {
    return `${startLabel} → ${endLabel}`;
  }

  return startLabel || endLabel || "";
};

const formatTimeRange = (event: Event): string => {
  const { start_time, end_time } = event;
  if (!start_time && !end_time) return "";
  if (start_time && end_time && start_time !== end_time) {
    return `${start_time} → ${end_time}`;
  }
  return start_time || end_time || "";
};

const getMonthLabel = (event: Event): string | null => {
  if (!event.start_date) return null;
  const dt = new Date(event.start_date);
  if (Number.isNaN(dt.getTime())) return null;
  return dt.toLocaleString(undefined, { month: "long", year: "numeric" });
};

const labelStyle: React.CSSProperties = {
  display: "block",
  marginBottom: "0.25rem",
  fontSize: "12px",
  fontWeight: 500,
  color: "#4b5563",
};

const inputStyle: React.CSSProperties = {
  width: "100%",
  padding: "0.45rem 0.6rem",
  borderRadius: "8px",
  border: "1px solid #d1d5db",
  fontSize: "14px",
};

const selectStyle: React.CSSProperties = {
  ...inputStyle,
};

const tagPillStyle: React.CSSProperties = {
  display: "inline-block",
  padding: "2px 8px",
  borderRadius: "999px",
  backgroundColor: "#eff6ff",
  fontSize: "11px",
  marginRight: "4px",
  marginBottom: "4px",
};

const App: React.FC = () => {
  const [events, setEvents] = useState<Event[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [planningLevels, setPlanningLevels] = useState<PlanningLevel[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedParentId, setSelectedParentId] = useState<number | null>(null);
  const [eventBeingEdited, setEventBeingEdited] = useState<Event | null>(null);
  const [formMode, setFormMode] = useState<"create" | "edit" | "duplicate">(
    "create"
  );
  const [eventsViewMode, setEventsViewMode] = useState<
    "list" | "calendar"
  >("list");
  const [isEventFormOpen, setIsEventFormOpen] = useState(false);

  const [collapsedEventIds, setCollapsedEventIds] = useState<number[]>([]);

  const [textFilter, setTextFilter] = useState("");
  const [preacherFilter, setPreacherFilter] = useState("");
  const [categoryFilterId, setCategoryFilterId] = useState<number | "">("");
  const [planningLevelFilterId, setPlanningLevelFilterId] = useState<
    number | ""
  >("");
  const [startDateFilter, setStartDateFilter] = useState("");
  const [endDateFilter, setEndDateFilter] = useState("");

  // switch between Events, Categories and Planning Levels view
  const [activeView, setActiveView] = useState<
    "events" | "categories" | "planningLevels"
  >("events");

  // authentication state
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);

  useEffect(() => {
    // on first load, restore token from localStorage
    loadAuthTokenFromStorage();
    const token = getAuthToken();
    setIsAuthenticated(!!token);
  }, []);

  const handleLoginSuccess = () => {
    setIsAuthenticated(true);
    // after login, load data
    loadEvents();
    loadCategories();
    loadPlanningLevels();
  };

  const handleLogout = () => {
    setAuthToken(null);
    setIsAuthenticated(false);
    setEvents([]);
    setCategories([]);
    setPlanningLevels([]);
  };

  const handleAuthError = () => {
    // if backend returns 401, force logout
    handleLogout();
  };

  const loadEvents = async () => {
    try {
      setLoading(true);
      setError(null);

      const res = await apiFetch("/events");
      if (res.status === 401) {
        handleAuthError();
        return;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }

      const data = await res.json();
      setEvents(data);
    } catch (err) {
      console.error("Error loading events", err);
      setError("Error loading events");
    } finally {
      setLoading(false);
    }
  };

  const loadCategories = async () => {
    try {
      const res = await apiFetch("/categories");
      if (res.status === 401) {
        handleAuthError();
        return;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      const data = await res.json();
      setCategories(data);
    } catch (err) {
      console.error("Error loading categories", err);
    }
  };

  const loadPlanningLevels = async () => {
    try {
      const res = await apiFetch("/planning-levels");
      if (res.status === 401) {
        handleAuthError();
        return;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      const data = await res.json();
      setPlanningLevels(data);
    } catch (err) {
      console.error("Error loading planning levels", err);
    }
  };

  const deleteEvent = async (eventId: number) => {
    const confirmed = window.confirm(
      "Are you sure you want to delete this event?"
    );
    if (!confirmed) return;

    try {
      const res = await apiFetch(`/events/${eventId}`, {
        method: "DELETE",
      });

      if (res.status === 401) {
        handleAuthError();
        return;
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }

      // If we are currently editing this event, exit edit mode
      setEventBeingEdited((current) =>
        current && current.id === eventId ? null : current
      );

      if (eventBeingEdited && eventBeingEdited.id === eventId) {
        setFormMode("create");
        setSelectedParentId(null);
      }

      // Reload list after delete
      await loadEvents();
    } catch (err) {
      console.error("Error deleting event", err);
      window.alert("Failed to delete event. Please check the console/logs.");
    }
  };

  // initial data load when already authenticated (e.g. after refresh)
  useEffect(() => {
    if (isAuthenticated) {
      loadEvents();
      loadCategories();
      loadPlanningLevels();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAuthenticated]);

  // Apply filters to events (tree-aware: children can make parents visible, parents include descendants)
  const filtersActive =
    textFilter.trim() ||
    preacherFilter.trim() ||
    categoryFilterId !== "" ||
    planningLevelFilterId !== "" ||
    startDateFilter ||
    endDateFilter;

  const matchesFilters = (event: Event): boolean => {
    // Date range on start_date
    if (
      startDateFilter &&
      (!event.start_date || event.start_date < startDateFilter)
    ) {
      return false;
    }
    if (
      endDateFilter &&
      (!event.start_date || event.start_date > endDateFilter)
    ) {
      return false;
    }

    // Category filter
    if (categoryFilterId !== "") {
      const cid = Number(categoryFilterId);
      const hasCategory =
        event.categories && event.categories.some((c) => c.id === cid);
      if (!hasCategory) return false;
    }

    // Planning level filter
    if (planningLevelFilterId !== "") {
      const pid = Number(planningLevelFilterId);
      const hasPlanningLevel =
        event.planning_levels &&
        event.planning_levels.some((p) => p.id === pid);
      if (!hasPlanningLevel) return false;
    }

    // Preacher filter (substring, case-insensitive)
    if (preacherFilter.trim()) {
      const preacherText = (event.preacher || "").toLowerCase();
      if (!preacherText.includes(preacherFilter.toLowerCase())) {
        return false;
      }
    }

    // Full-text filter (title, preacher, sermon, remarks, notes, clarification)
    if (textFilter.trim()) {
      const needle = textFilter.toLowerCase();
      const haystack = [
        event.title,
        event.preacher,
        event.sermon_title,
        event.remarks,
        event.internal_notes,
        event.clarification,
      ]
        .filter(Boolean)
        .join(" ")
        .toLowerCase();

      if (!haystack.includes(needle)) {
        return false;
      }
    }

    return true;
  };

  let filteredEvents: Event[];

  if (!filtersActive) {
    // No filters -> show all events
    filteredEvents = events;
  } else {
    // 1) Prebuild helper maps
    const idToEvent = new Map<number, Event>(events.map((e) => [e.id, e]));
    const childrenByParent = new Map<number, Event[]>();
    events.forEach((e) => {
      if (e.parent_id != null) {
        const list = childrenByParent.get(e.parent_id) || [];
        list.push(e);
        childrenByParent.set(e.parent_id, list);
      }
    });

    // 2) Find all events that directly match the filters
    const matchingIds = new Set<number>();
    events.forEach((event) => {
      if (matchesFilters(event)) {
        matchingIds.add(event.id);
      }
    });

    // 3) Collect all visible IDs: matching events, their ancestors, and their descendants
    const visibleIds = new Set<number>();

    const addWithAncestors = (eventId: number) => {
      let currentId: number | null = eventId;
      while (currentId != null) {
        if (visibleIds.has(currentId)) break;
        visibleIds.add(currentId);
        const current = idToEvent.get(currentId);
        if (!current || current.parent_id == null) break;
        currentId = current.parent_id ?? null;
      }
    };

    const addDescendants = (eventId: number) => {
      const children = childrenByParent.get(eventId) || [];
      for (const child of children) {
        if (!visibleIds.has(child.id)) {
          visibleIds.add(child.id);
          addDescendants(child.id);
        }
      }
    };

    matchingIds.forEach((id) => {
      addWithAncestors(id); // ensure parent chain is visible
      addDescendants(id); // ensure all children are visible
    });

    filteredEvents = events.filter((e) => visibleIds.has(e.id));
  }

  // Parent preselection: editing event takes priority, otherwise "Add sub-event"
  const initialParentIdForForm =
    eventBeingEdited && eventBeingEdited.parent_id != null
      ? eventBeingEdited.parent_id
      : selectedParentId;

  const buttonBaseStyle: React.CSSProperties = {
    borderRadius: "999px",
    border: "1px solid #d1d5db",
    padding: "0.3rem 0.8rem",
    fontSize: "13px",
    backgroundColor: "#f9fafb",
    cursor: "pointer",
  };

  const primaryButtonStyle: React.CSSProperties = {
    ...buttonBaseStyle,
    backgroundColor: "#4f46e5",
    color: "#ffffff",
    borderColor: "#4f46e5",
  };

  const dangerButtonStyle: React.CSSProperties = {
    ...buttonBaseStyle,
    backgroundColor: "#b91c1c",
    borderColor: "#b91c1c",
    color: "#ffffff",
  };

  const renderEventNode = (event: Event, depth: number = 0): JSX.Element => {
  const children = filteredEvents.filter((e) => e.parent_id === event.id);
  const isChild = depth > 0;
  const dateLabel = formatDisplayDate(event);
  const timeLabel = formatTimeRange(event);
  const isCollapsed = collapsedEventIds.includes(event.id);

  const toggleCollapse = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (children.length === 0) return;
    setCollapsedEventIds((prev) =>
      prev.includes(event.id)
        ? prev.filter((id) => id !== event.id)
        : [...prev, event.id]
    );
  };

  const cardPadding = isChild ? "0.5rem 0.75rem" : "0.75rem 1rem";
  const titleFontSize = isChild ? "14px" : "15px";

  return (
    <React.Fragment key={event.id}>
      <li
        style={{
          marginBottom: isChild ? "0.25rem" : "0.9rem",
          marginLeft: `${depth * 24}px`,
        }}
      >
        <div
          onClick={() => {
            setEventBeingEdited(event);
            setFormMode("edit");
            setSelectedParentId(event.parent_id ?? null);
            setIsEventFormOpen(true);
          }}
          style={{
            ...cardBaseStyle,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-start",
            padding: cardPadding,
            cursor: "pointer",
          }}
        >
          <div style={{ flex: 1, minWidth: 0 }}>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                gap: "0.5rem",
                marginBottom: "0.25rem",
              }}
            >
              {children.length > 0 && (
                <button
                  type="button"
                  onClick={toggleCollapse}
                  style={{
                    border: "none",
                    background: "transparent",
                    cursor: "pointer",
                    padding: 0,
                    fontSize: "12px",
                  }}
                >
                  {isCollapsed ? "▸" : "▾"}
                </button>
              )}
              <h2
                style={{
                  margin: 0,
                  fontSize: titleFontSize,
                  fontWeight: isChild ? 500 : 600,
                  color: "#0f172a",
                  whiteSpace: "nowrap",
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                }}
              >
                {event.title}
              </h2>
            </div>

            <div
              style={{
                display: "flex",
                flexWrap: "wrap",
                alignItems: "center",
                gap: "0.5rem",
                fontSize: "11px",
                color: "#6b7280",
              }}
            >
              {dateLabel && <span>{dateLabel}</span>}
              {timeLabel && <span>• {timeLabel}</span>}
              {event.planning_levels &&
                event.planning_levels.length > 0 && (
                  <span>
                    •{" "}
                    {event.planning_levels
                      .map((pl) => pl.name)
                      .join(", ")}
                  </span>
                )}
            </div>

            {event.categories && event.categories.length > 0 && (
              <div
                style={{
                  marginTop: "0.25rem",
                  display: "flex",
                  flexWrap: "wrap",
                  gap: "0.25rem",
                }}
              >
                {event.categories.map((cat) => {
                  const bgColor = cat.color_hex || "#eef2ff";
                  const symbol = cat.symbol || "";
                  return (
                    <span
                      key={cat.id}
                      style={{
                        display: "inline-flex",
                        alignItems: "center",
                        borderRadius: "999px",
                        padding: "2px 6px",
                        fontSize: "11px",
                        fontWeight: 500,
                        backgroundColor: bgColor,
                        color: "#111827",
                        maxWidth: "100%",
                      }}
                    >
                      {symbol && (
                        <span
                          style={{
                            marginRight: "4px",
                            fontSize: "12px",
                          }}
                        >
                          {symbol}
                        </span>
                      )}
                      <span
                        style={{
                          whiteSpace: "nowrap",
                          overflow: "hidden",
                          textOverflow: "ellipsis",
                        }}
                      >
                        {cat.name}
                      </span>
                    </span>
                  );
                })}
              </div>
            )}
          </div>

          <div
            style={{
              marginLeft: "0.75rem",
              display: "flex",
              flexWrap: "wrap",
              gap: "0.25rem",
              justifyContent: "flex-end",
            }}
          >
            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation();
                setEventBeingEdited(event);
                setFormMode("edit");
                setSelectedParentId(event.parent_id ?? null);
                setIsEventFormOpen(true);
              }}
              style={buttonBaseStyle}
            >
              Edit
            </button>

            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation();
                setEventBeingEdited(event);
                setFormMode("duplicate");
                setSelectedParentId(event.parent_id ?? null);
                setIsEventFormOpen(true);
              }}
              style={buttonBaseStyle}
            >
              Duplicate
            </button>

            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation();
                setEventBeingEdited(null);
                setFormMode("create");
                setSelectedParentId(event.id);
                setIsEventFormOpen(true);
              }}
              style={primaryButtonStyle}
            >
              Add sub-event
            </button>

            <button
              type="button"
              onClick={(e) => {
                e.stopPropagation();
                deleteEvent(event.id);
              }}
              style={dangerButtonStyle}
            >
              Delete
            </button>
          </div>
        </div>
      </li>

      {!isCollapsed &&
        children.map((child) => renderEventNode(child, depth + 1))}
    </React.Fragment>
  );
};


const renderEventsWithMonths = (): JSX.Element[] => {
  const roots = filteredEvents.filter((event) => event.parent_id == null);

  let lastMonthLabel: string | null = null;
  const items: JSX.Element[] = [];

  roots.forEach((event) => {
    const monthLabel = getMonthLabel(event);
    if (monthLabel && monthLabel !== lastMonthLabel) {
      lastMonthLabel = monthLabel;
      items.push(
        <li
          key={`month-${monthLabel}`}
          style={{
            margin: "1.25rem 0 0.5rem",
          }}
        >
          <div
            style={{
              borderBottom: "1px solid #e5e7eb",
              paddingBottom: "0.25rem",
              fontSize: "12px",
              fontWeight: 600,
              color: "#4b5563",
            }}
          >
            {monthLabel}
          </div>
        </li>
      );
    }

    items.push(renderEventNode(event, 0));
  });

  return items;
};

  // if not authenticated, show login screen only
  if (!isAuthenticated) {
    return <Login onLoginSuccess={handleLoginSuccess} />;
  }

  return (
    <AppLayout
      activeView={activeView}
      onChangeView={setActiveView}
      onLogout={handleLogout}
    >
      {activeView === "events" && (
        <>
          {loading && <p>Loading events…</p>}
          {error && <p style={{ color: "red" }}>{error}</p>}

<div
  style={{
    display: "flex",
    justifyContent: "flex-end",
    marginBottom: "1rem",
  }}
>
  <button
    type="button"
    onClick={() => {
      setEventBeingEdited(null);
      setFormMode("create");
      setSelectedParentId(null);
      setIsEventFormOpen(true);
    }}
    style={primaryButtonStyle}
  >
    Create event
  </button>
</div>


          {/* Filters */}
          <div
            style={{
              ...cardBaseStyle,
              marginBottom: "1.25rem",
              maxWidth: "900px",
            }}
          >
            <div
              style={{
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: "0.75rem",
              }}
            >
              <div>
                <h2
                  style={{
                    margin: 0,
                    fontSize: "15px",
                    fontWeight: 600,
                  }}
                >
                  Filters
                </h2>
                <div style={subtleTextStyle}>
                  Narrow down events by text, person, date, category or planning
                  level.
                </div>
              </div>
              <button
                type="button"
                onClick={() => {
                  setTextFilter("");
                  setPreacherFilter("");
                  setCategoryFilterId("");
                  setPlanningLevelFilterId("");
                  setStartDateFilter("");
                  setEndDateFilter("");
                }}
                style={buttonBaseStyle}
              >
                Reset
              </button>
            </div>

            <div
              style={{
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(190px, 1fr))",
                gap: "0.75rem",
              }}
            >
              <div>
                <label style={labelStyle}>Search text</label>
                <input
                  type="text"
                  value={textFilter}
                  onChange={(e) => setTextFilter(e.target.value)}
                  style={inputStyle}
                  placeholder="Title, sermon, notes…"
                />
              </div>

              <div>
                <label style={labelStyle}>Preacher</label>
                <input
                  type="text"
                  value={preacherFilter}
                  onChange={(e) => setPreacherFilter(e.target.value)}
                  style={inputStyle}
                  placeholder="Filter by preacher"
                />
              </div>

              <div>
                <label style={labelStyle}>Start date (from)</label>
                <input
                  type="date"
                  value={startDateFilter}
                  onChange={(e) => setStartDateFilter(e.target.value)}
                  style={inputStyle}
                />
              </div>

              <div>
                <label style={labelStyle}>Start date (to)</label>
                <input
                  type="date"
                  value={endDateFilter}
                  onChange={(e) => setEndDateFilter(e.target.value)}
                  style={inputStyle}
                />
              </div>

              <div>
                <label style={labelStyle}>Category</label>
                <select
                  value={categoryFilterId}
                  onChange={(e) =>
                    setCategoryFilterId(
                      e.target.value === "" ? "" : Number(e.target.value)
                    )
                  }
                  style={selectStyle}
                >
                  <option value="">All</option>
                  {categories.map((cat) => (
                    <option key={cat.id} value={cat.id}>
                      {cat.name}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label style={labelStyle}>Planning level</label>
                <select
                  value={planningLevelFilterId}
                  onChange={(e) =>
                    setPlanningLevelFilterId(
                      e.target.value === "" ? "" : Number(e.target.value)
                    )
                  }
                  style={selectStyle}
                >
                  <option value="">All</option>
                  {planningLevels.map((pl) => (
                    <option key={pl.id} value={pl.id}>
                      {pl.name}
                    </option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          {!loading && !error && events.length === 0 && (
            <p style={subtleTextStyle}>
              No events yet. Create some using the form above.
            </p>
          )}

          {isEventFormOpen && (
  <div
    style={{
      position: "fixed",
      inset: 0,
      backgroundColor: "rgba(15, 23, 42, 0.45)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 50,
    }}
    onClick={() => {
      setIsEventFormOpen(false);
      setEventBeingEdited(null);
      setFormMode("create");
      setSelectedParentId(null);
    }}
  >
    <div
      style={{
        maxWidth: "880px",
        width: "100%",
        maxHeight: "90vh",
        overflowY: "auto",
        padding: "1rem 1.25rem 1.25rem",
      }}
      onClick={(e) => e.stopPropagation()}
    >
      <AddEventForm
        mode={formMode}
        eventToEdit={eventBeingEdited}
        onCancelEdit={() => {
          setIsEventFormOpen(false);
          setEventBeingEdited(null);
          setFormMode("create");
          setSelectedParentId(null);
        }}
        onCreated={() => {
          loadEvents();
          setIsEventFormOpen(false);
          setEventBeingEdited(null);
          setFormMode("create");
          setSelectedParentId(null);
        }}
        parentOptions={events}
        categoryOptions={categories}
        planningLevelOptions={planningLevels}
        initialParentId={initialParentIdForForm}
      />
    </div>
  </div>
)}

{!loading && !error && filteredEvents.length > 0 && (
            <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
              {renderEventsWithMonths()}
            </ul>
          )}

          {!loading &&
            !error &&
            filteredEvents.length === 0 &&
            events.length > 0 && (
              <p style={subtleTextStyle}>
                No events match the current filters.
              </p>
            )}
        </>
      )}

      {activeView === "categories" && <CategoryManagement />}

      {activeView === "planningLevels" && <PlanningLevelsPanel />}
    </AppLayout>
  );
};

export default App;
